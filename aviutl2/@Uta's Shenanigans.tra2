@[Track]Bezier
--timecontrol
--param:0
function lerp(a, b, t)
    return a * (1 - t) + b * t
end

function bezier(s, e, t)
	if s == e then
	    return obj.getpoint(s, 0)
	else
		local p1 = bezier(s, e-1, t)
		local p2 = bezier(s+1, e, t)
		return lerp(p1, p2, t)
	end
end

function bezier3D(s, e, t)
    if s == e then
        return obj.getpoint(s, 0, 3)
    else
        local p1x, p1y, p1z = bezier3D(s, e-1, t)
        local p2x, p2y, p2z = bezier3D(s+1, e, t)
        return lerp(p1x, p2x, t), lerp(p1y, p2y, t), lerp(p1z, p2z, t)
    end
end

function dist(x1, y1, z1, x2, y2, z2)
    local x = x2 - x1
    local y = y2 - y1
    local z = z2 - z1
    return math.sqrt(x * x + y * y + z * z)
end

n = obj.getpoint("num")
length = obj.getpoint("time", n - 1)
amt = obj.getpoint("timecontrol", "time") / length
if obj.getpoint("param") == 0 then
    return bezier(0, n-1, amt)
else
    local arcLength = {0}
    local divs = math.max(16, math.floor(length * obj.getpoint("framerate")))
    local px, py, pz = obj.getpoint(0, 0, 3)
    local sum = 0

    for i = 1, divs-1 do
        local x, y, z = bezier3D(0, n-1, i / (divs - 1))
        sum = sum + dist(px, py, pz, x, y, z)
        table.insert(arcLength, sum)
        px, py, pz = x, y, z
    end

    local t = 0
    local target = amt * sum
    local low = 1
    local high = #arcLength
    while low < high do
        local mid = low + math.floor((high - low) / 2)
        if arcLength[mid] < target then
            low = mid + 1
        else
            high = mid
        end
    end
    low = math.max(1, low - 1)

    local found = arcLength[low]
    if found == target then
        t = (low - 1) / divs
    else
        t = (low - 1 + (target - found) / (arcLength[low + 1] - found)) / divs
    end
    return bezier(0, n-1, t)
end

@[Track]Bezier Chain
--timecontrol
--param:0
function lerp(a, b, t)
    return a * (1 - t) + b * t
end

function quadBezier(a, b, c, t)
    local d = lerp(a, b, t)
    local e = lerp(b, c, t)
    
    return lerp(d, e, t)
end

function cubicBezier(a, b, c, d, t)
    local e = quadBezier(a, b, c, t)
    local f = quadBezier(b, c, d, t)
    
    return lerp(e, f, t)
end

function dist(x1, y1, z1, x2, y2, z2)
    local x = x2 - x1
    local y = y2 - y1
    local z = z2 - z1
    return math.sqrt(x * x + y * y + z * z)
end

function bezierChain(t)
    local num = obj.getpoint("num")
    local index = t
    
    local segmentIndex = 3 * math.floor(index / 3)
    local segmentLength = math.min(num - segmentIndex, 4)
    if segmentLength == 1 then
        segmentLength = 4
        segmentIndex = num - 4
    end
    local t = (index - segmentIndex) / (segmentLength - 1)
    if segmentLength == 2 then
        local x1, y1, z1 = obj.getpoint(segmentIndex, 0, 3)
        local x2, y2, z2 = obj.getpoint(segmentIndex + 1, 0, 3)
        return lerp(x1, x2, t), lerp(y1, y2, t), lerp(z1, z2, t)
    elseif segmentLength == 3 then
        local x1, y1, z1 = obj.getpoint(segmentIndex, 0, 3)
        local x2, y2, z2 = obj.getpoint(segmentIndex + 1, 0, 3)
        local x3, y3, z3 = obj.getpoint(segmentIndex + 2, 0, 3)
        return quadBezier(x1, x2, x3, t), quadBezier(y1, y2, y3, t), quadBezier(z1, z2, z3, t)
    elseif segmentLength == 4 then
        local x1, y1, z1 = obj.getpoint(segmentIndex, 0, 3)
        local x2, y2, z2 = obj.getpoint(segmentIndex + 1, 0, 3)
        local x3, y3, z3 = obj.getpoint(segmentIndex + 2, 0, 3)
        local x4, y4, z4 = obj.getpoint(segmentIndex + 3, 0, 3)
        return cubicBezier(x1, x2, x3, x4, t), cubicBezier(y1, y2, y3, y4, t), cubicBezier(z1, z2, z3, z4, t)
    end
    return obj.getpoint(segmentIndex, 0, 3)
end

n = obj.getpoint("num")
length = obj.getpoint("time", n - 1)
amt = (n - 1) * obj.getpoint("timecontrol", "time") / length
if obj.getpoint("param") == 0 then
    x, y, z = bezierChain(amt)
    return x
else
    local arcLength = {0}
    local divs = math.max(16, math.floor(length * obj.getpoint("framerate")))
    local px, py, pz = obj.getpoint(0, 0, 3)
    local sum = 0

    for i = 1, divs-1 do
        local x, y, z = bezierChain((n - 1) * i / (divs - 1))
        sum = sum + dist(px, py, pz, x, y, z)
        table.insert(arcLength, sum)
        px, py, pz = x, y, z
    end

    local t = 0
    local target = sum * amt / (n - 1)
    local low = 1
    local high = #arcLength
    while low < high do
        local mid = low + math.floor((high - low) / 2)
        if arcLength[mid] < target then
            low = mid + 1
        else
            high = mid
        end
    end
    low = math.max(1, low - 1)

    local found = arcLength[low]
    if found == target then
        t = (low - 1) / divs
    else
        t = (low - 1 + (target - found) / (arcLength[low + 1] - found)) / divs
    end
    t = t * (n - 1)
    x, y, z = bezierChain(t)
    return x
end

@[Track]Hermite Spline
--speed:0,0
--param:100
--timecontrol
function hermite(a, b, c, d, t, ten, bi)
	local m0, m1, t2, t3
	local w, x, y, z

	t2 = t*t
	t3 = t2*t

	m0 = ((b - a) * (1 + bi) * (1 - ten) / 2) + ((c - b) * (1 - bi) * (1 - ten) / 2)
	m1 = ((c - b) * (1 + bi) * (1 - ten) / 2) + ((d - c) * (1 - bi) * (1 - ten) / 2)

	w = 2*t3 - 3*t2 + 1
	x = t3 - 2*t2 + t
	y = t3 - t2
	z = -2*t3 + 3*t2

	return w*b + x*m0 + y*m1 + z*c
end
ten = obj.getpoint("param") / 100.0 - 1
bi = 0
if obj.getpoint("accelerate") then
    bi = bi - 1
end
if obj.getpoint("decelerate") then
    bi = bi + 1
end

idx, rat = math.modf(obj.getpoint("timecontrol", "index"))

return hermite(obj.getpoint(idx-1, 0), obj.getpoint(idx, 0), obj.getpoint(idx+1, 0), obj.getpoint(idx+2, 0), rat, ten, bi)

@[Track]Catmull-Rom Spline
--param:100
--timecontrol
function distance(x0, y0, z0, t0, x1, y1, z1, t1)
	local x = x0 - x1
	local y = y0 - y1
	local z = z0 - z1
	local t = (1000000 * (t0 - t1))
	return math.sqrt(x * x + y * y + z * z + t * t)
end

function catmullrom(x0, y0, z0, tt0, x1, y1, z1, tt1, x2, y2, z2, tt2, x3, y3, z3, tt3, amt, a)
	local t0 = 0
	local t1 = math.pow(distance(x0, y0, z0, tt0, x1, y1, z1, tt1), a)
	local t2 = t1 + math.pow(distance(x1, y1, z1, tt1, x2, y2, z2, tt2), a)
	local t3 = t2 + math.pow(distance(x2, y2, z2, tt2, x3, y3, z3, tt3), a)
	
	local t = t1 * (1 - amt) + t2 * amt
	
	local a1x = x0 * (t1 - t) / (t1 - t0) + x1 * (t - t0) / (t1 - t0)
	local a2x = x1 * (t2 - t) / (t2 - t1) + x2 * (t - t1) / (t2 - t1)
	local a3x = x2 * (t3 - t) / (t3 - t2) + x3 * (t - t2) / (t3 - t2)
	
	local b1x = a1x * (t2 - t) / (t2 - t0) + a2x * (t - t0) / (t2 - t0)
	local b2x = a2x * (t3 - t) / (t3 - t1) + a3x * (t - t1) / (t3 - t1)
	
	local cx = b1x * (t2 - t) / (t2 - t1) + b2x * (t - t1) / (t2 - t1)
	
	local a1y = y0 * (t1 - t) / (t1 - t0) + y1 * (t - t0) / (t1 - t0)
	local a2y = y1 * (t2 - t) / (t2 - t1) + y2 * (t - t1) / (t2 - t1)
	local a3y = y2 * (t3 - t) / (t3 - t2) + y3 * (t - t2) / (t3 - t2)
	
	local b1y = a1y * (t2 - t) / (t2 - t0) + a2y * (t - t0) / (t2 - t0)
	local b2y = a2y * (t3 - t) / (t3 - t1) + a3y * (t - t1) / (t3 - t1)
	
	local cy = b1y * (t2 - t) / (t2 - t1) + b2y * (t - t1) / (t2 - t1)
	
	local a1z = z0 * (t1 - t) / (t1 - t0) + z1 * (t - t0) / (t1 - t0)
	local a2z = z1 * (t2 - t) / (t2 - t1) + z2 * (t - t1) / (t2 - t1)
	local a3z = z2 * (t3 - t) / (t3 - t2) + z3 * (t - t2) / (t3 - t2)
	
	local b1z = a1z * (t2 - t) / (t2 - t0) + a2z * (t - t0) / (t2 - t0)
	local b2z = a2z * (t3 - t) / (t3 - t1) + a3z * (t - t1) / (t3 - t1)
	
	local cz = b1z * (t2 - t) / (t2 - t1) + b2z * (t - t1) / (t2 - t1)
	
	return cx, cy, cz
end

alpha = obj.getpoint("param") / 100.0

idx, rat = math.modf(obj.getpoint("timecontrol", "index"))
num = obj.getpoint("num")

if idx > 0 then
	x0, y0, z0 = obj.getpoint(idx - 1, 0, 3)
	t0 = obj.getpoint("time", idx - 1)
else
	x0, y0, z0 = obj.getpoint(0, 0, 3)
	t0 = -obj.getpoint("time", 1)
end

if idx < num - 2 then
	x3, y3, z3 = obj.getpoint(idx + 2, 0, 3)
	t3 = obj.getpoint("time", idx + 2)
else
	x3, y3, z3 = obj.getpoint(num - 1, 0, 3)
	t3 = 2 * obj.getpoint("time", num - 1) - obj.getpoint("time", num - 2)
end

x1, y1, z1 = obj.getpoint(idx    , 0, 3)
x2, y2, z2 = obj.getpoint(idx + 1, 0, 3)
t1 = obj.getpoint("time", idx)
t2 = obj.getpoint("time", idx + 1)

i, dim = obj.getpoint("link")

if dim < 3 then
	z0, z1, z2, z3 = 0, 0, 0
	if dim < 2 then
		y0, y1, y2, y3 = 0, 0, 0
	end
end

x, y, z = catmullrom(x0, y0, z0, t0, x1, y1, z1, t1, x2, y2, z2, t2, x3, y3, z3, t3, rat, alpha)

return x

@[Track]Snappy Random
--twopoint
--param:12
--timecontrol
return obj.rand(obj.getpoint(0, 0), obj.getpoint(1, 0), math.floor(obj.getpoint("timecontrol", "time") * obj.getpoint("param")), 0)